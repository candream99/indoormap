<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>월드메디 3D 가상 투어 (충돌 감지 적용)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; background: rgba(0,0,0,0.7); z-index: 10; cursor: pointer;
            text-align: center;
        }
        #overlay h1 { margin: 0 0 10px; font-size: 24px; }
        #overlay p { margin: 0; font-size: 14px; color: #ccc; }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>화면을 클릭하여 시작하세요</h1>
        <p>W, A, S, D: 이동 | 마우스: 시선 전환 | ESC: 종료</p>
        <p style="margin-top: 20px; color: #aaa;">(이제 벽을 통과할 수 없습니다)</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Octree } from 'three/addons/math/Octree.js';
        import { Capsule } from 'three/addons/math/Capsule.js';

        // --- 전역 변수 설정 ---
        const clock = new THREE.Clock();
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccee);
        scene.fog = new THREE.Fog(0x88ccee, 0, 50);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.rotation.order = 'YXZ';

        // 조명 설정 (전체적으로 밝게)
        const fillLight = new THREE.HemisphereLight(0xffffff, 0x888888, 2); // 밝기 높임
        fillLight.position.set(2, 1, 1);
        scene.add(fillLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(-5, 25, -1);
        scene.add(dirLight);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 물리 및 충돌 관련 변수 ---
        const GRAVITY = 30; // 중력 가속도
        const STEPS_PER_FRAME = 5; // 물리 계산 정밀도 (높을수록 벽 뚫림 방지)
        
        // Octree: 건물 전체의 충돌 데이터
        const worldOctree = new Octree();
        
        // Capsule: 플레이어의 몸 (시작위치: x=0, y=5, z=0 / 반지름: 0.35 / 키: 1.35 + 0.35*2)
        const playerCollider = new Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 1.35, 0), 0.35);
        
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();
        let playerOnFloor = false;

        // 키 입력 상태
        const keyStates = {};

        // --- 이벤트 리스너 ---
        document.addEventListener('keydown', (event) => { keyStates[event.code] = true; });
        document.addEventListener('keyup', (event) => { keyStates[event.code] = false; });
        
        document.body.addEventListener('mousedown', () => {
            document.body.requestPointerLock();
        });
        
        // Pointer Lock 상태 변화에 따른 오버레이 처리
        document.addEventListener('pointerlockchange', () => {
             const overlay = document.getElementById('overlay');
             if (document.pointerLockElement === document.body) {
                 overlay.style.display = 'none';
             } else {
                 overlay.style.display = 'flex';
             }
        });

        document.body.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= event.movementX / 500;
                camera.rotation.x -= event.movementY / 500;
            }
        });

        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 모델 로드 (가장 중요한 부분) ---
        const loader = new GLTFLoader();
        
        // ★★★ 여기에 본인의 파일명을 넣으세요 ★★★
        loader.load('model.glb', (gltf) => {
            scene.add(gltf.scene);

            // 모델의 모든 메쉬를 순회하며 그림자 및 충돌 데이터 생성
            gltf.scene.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // 충돌 계산을 위해 라이트맵이나 투명한 물체는 제외할 수도 있음
                    if (child.material.map) {
                        child.material.map.anisotropy = 4;
                    }
                }
            });

            // ★ Octree에 모델 데이터 입력 (이제부터 벽이 됩니다)
            worldOctree.fromGraphNode(gltf.scene);
            
            console.log("모델 로드 및 충돌 데이터 생성 완료");

        }, undefined, (error) => {
            console.error(error);
        });


        // --- 물리 엔진 로직 ---
        function playerCollisions() {
            const result = worldOctree.capsuleIntersect(playerCollider);
            playerOnFloor = false;

            if (result) {
                playerOnFloor = result.normal.y > 0;
                if (!playerOnFloor) {
                    playerVelocity.addScaledVector(result.normal, -result.normal.dot(playerVelocity));
                }
                // 충돌한 깊이만큼 밀어냄
                playerCollider.translate(result.normal.multiplyScalar(result.depth));
            }
        }

        function updatePlayer(deltaTime) {
            let damping = Math.exp(-4 * deltaTime) - 1;
            if (!playerOnFloor) {
                playerVelocity.y -= GRAVITY * deltaTime;
                damping *= 0.1; // 공중에서는 마찰력 감소
            }

            playerVelocity.addScaledVector(playerVelocity, damping);
            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerCollider.translate(deltaPosition);

            playerCollisions();

            camera.position.copy(playerCollider.end);
        }

        function getForwardVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            return playerDirection;
        }

        function getSideVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            playerDirection.cross(camera.up);
            return playerDirection;
        }

        function controls(deltaTime) {
            // 이동 속도 설정 (걷기: 15, 달리기: 30)
            const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);

            if (keyStates['KeyW']) {
                playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
            }
            if (keyStates['KeyS']) {
                playerVelocity.add(getForwardVector().multiplyScalar(-speedDelta));
            }
            if (keyStates['KeyA']) {
                playerVelocity.add(getSideVector().multiplyScalar(-speedDelta));
            }
            if (keyStates['KeyD']) {
                playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
            }
        }

        // --- 텔레포트 (낙하 방지) ---
        function teleportPlayerIfOob() {
            if (camera.position.y <= -25) {
                playerCollider.start.set(0, 0.35, 0);
                playerCollider.end.set(0, 1.35, 0);
                playerCollider.radius = 0.35;
                camera.position.copy(playerCollider.end);
                camera.rotation.set(0, 0, 0);
                playerVelocity.set(0, 0, 0);
            }
        }

        // --- 메인 루프 ---
        function animate() {
            const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;

            // 물리 계산의 정밀도를 위해 한 프레임을 여러 번 쪼개서 계산
            for (let i = 0; i < STEPS_PER_FRAME; i++) {
                controls(deltaTime);
                updatePlayer(deltaTime);
                teleportPlayerIfOob();
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
