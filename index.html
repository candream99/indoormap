<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>월드메디 3D 실내지도 테스트</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; background: rgba(0,0,0,0.7); z-index: 10; cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>화면을 클릭하여 가상 투어 시작</h1>
        <p>W, A, S, D: 이동 | 마우스: 시선 전환 | ESC: 종료</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let camera, scene, renderer, controls, loader;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0a0a0);
            scene.fog = new THREE.Fog(0xa0a0a0, 10, 500);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.6; // 사람 눈높이

            const light = new THREE.HemisphereLight(0xffffff, 0x444444, 3);
            scene.add(light);

            const sunLight = new THREE.DirectionalLight(0xffffff, 2);
            sunLight.position.set(5, 10, 7.5);
            scene.add(sunLight);

            // 컨트롤 설정
            controls = new PointerLockControls(camera, document.body);
            const overlay = document.getElementById('overlay');
            overlay.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => overlay.style.display = 'none');
            controls.addEventListener('unlock', () => overlay.style.display = 'flex');

            // 키보드 이벤트
            const onKeyDown = (e) => {
                if (e.code === 'KeyW') moveForward = true;
                if (e.code === 'KeyS') moveBackward = true;
                if (e.code === 'KeyA') moveLeft = true;
                if (e.code === 'KeyD') moveRight = true;
            };
            const onKeyUp = (e) => {
                if (e.code === 'KeyW') moveForward = false;
                if (e.code === 'KeyS') moveBackward = false;
                if (e.code === 'KeyA') moveLeft = false;
                if (e.code === 'KeyD') moveRight = false;
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // ★ 중요: 모델 불러오기
            loader = new GLTFLoader();
            // 아래 'model.glb' 부분을 본인의 파일명으로 바꾸세요.
            loader.load('model.glb', (gltf) => {
                scene.add(gltf.scene);
                console.log('모델 로드 완료');
            }, undefined, (error) => {
                console.log('아직 모델 파일이 없어 기본 바닥만 표시합니다.');
            });

            // 기본 그리드 바닥 (모델 없을 때 가이드용)
            const grid = new THREE.GridHelper(100, 100, 0x000000, 0x000000);
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add(grid);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            if (controls.isLocked) {
                const delta = (time - prevTime) / 1000;
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
            }
            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
