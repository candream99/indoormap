<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>월드메디 3D 가상 투어</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; font-family: sans-serif; }
        
        /* 로딩 화면 스타일 */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #00ff00; background: #000; z-index: 20;
            font-size: 24px; font-weight: bold;
        }

        /* 시작 안내 화면 스타일 (처음엔 숨김) */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; /* 로딩 완료 전까지 숨김 */
            flex-direction: column; align-items: center; justify-content: center;
            color: white; background: rgba(0,0,0,0.7); z-index: 10; cursor: pointer;
            text-align: center;
        }
        #overlay h1 { margin: 0 0 10px; font-size: 24px; }
        #overlay p { margin: 0; font-size: 14px; color: #ccc; }
    </style>
</head>
<body>
    <div id="loading">
        <p>모델 다운로드 및 물리 엔진 준비 중...</p>
        <p style="font-size:14px; color:#666;">(잠시만 기다려 주세요)</p>
    </div>

    <div id="overlay">
        <h1>로딩 완료! 화면을 클릭하세요</h1>
        <p>W, A, S, D: 이동 | 마우스: 시선 전환 | ESC: 종료</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Octree } from 'three/addons/math/Octree.js';
        import { Capsule } from 'three/addons/math/Capsule.js';

        // --- 전역 변수 ---
        const clock = new THREE.Clock();
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccee);
        scene.fog = new THREE.Fog(0x88ccee, 0, 50);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.rotation.order = 'YXZ';

        // ★ 로딩 상태 확인용 플래그 (이게 핵심!)
        let isModelLoaded = false;

        // 조명 설정
        const fillLight = new THREE.HemisphereLight(0xffffff, 0x888888, 2);
        fillLight.position.set(2, 1, 1);
        scene.add(fillLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(-5, 25, -1);
        scene.add(dirLight);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 물리 엔진 변수 ---
        const GRAVITY = 30;
        const STEPS_PER_FRAME = 5;
        
        const worldOctree = new Octree();
        // 플레이어: 반지름 0.35, 전체 높이 약 1.7m (시작 위치 y=5 에서 떨어뜨려봄)
        const playerCollider = new Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 1.35, 0), 0.35);
        
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();
        let playerOnFloor = false;
        const keyStates = {};

        // --- 이벤트 리스너 ---
        document.addEventListener('keydown', (event) => { keyStates[event.code] = true; });
        document.addEventListener('keyup', (event) => { keyStates[event.code] = false; });
        
        const overlay = document.getElementById('overlay');
        
        // 클릭 시 포인터 잠금 (게임 시작)
        overlay.addEventListener('click', () => {
            document.body.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
             if (document.pointerLockElement === document.body) {
                 overlay.style.display = 'none';
             } else {
                 // 로딩이 끝난 상태에서만 메뉴를 다시 보여줌
                 if(isModelLoaded) overlay.style.display = 'flex';
             }
        });

        document.body.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= event.movementX / 500;
                camera.rotation.x -= event.movementY / 500;
            }
        });

        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 모델 로드 (핵심 수정 부분) ---
        const loader = new GLTFLoader();
        
        loader.load('model.glb', (gltf) => { // 파일명 확인!
            scene.add(gltf.scene);

            // 그림자 설정
            gltf.scene.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // ★ Octree 생성 (벽 데이터 입력)
            worldOctree.fromGraphNode(gltf.scene);
            
            // ★ 로딩 완료 처리
            isModelLoaded = true; 
            console.log("모델 로딩 완료! 중력 활성화.");

            // 로딩 화면 끄고, 시작 화면 켜기
            document.getElementById('loading').style.display = 'none';
            document.getElementById('overlay').style.display = 'flex';

        }, (xhr) => {
            // 진행률 표시 (콘솔)
            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        }, (error) => {
            console.error('모델 로드 에러:', error);
        });


        // --- 물리 로직 ---
        function playerCollisions() {
            const result = worldOctree.capsuleIntersect(playerCollider);
            playerOnFloor = false;
            if (result) {
                playerOnFloor = result.normal.y > 0;
                if (!playerOnFloor) {
                    playerVelocity.addScaledVector(result.normal, -result.normal.dot(playerVelocity));
                }
                playerCollider.translate(result.normal.multiplyScalar(result.depth));
            }
        }

        function updatePlayer(deltaTime) {
            let damping = Math.exp(-4 * deltaTime) - 1;
            if (!playerOnFloor) {
                playerVelocity.y -= GRAVITY * deltaTime;
                damping *= 0.1;
            }
            playerVelocity.addScaledVector(playerVelocity, damping);
            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerCollider.translate(deltaPosition);

            playerCollisions();
            camera.position.copy(playerCollider.end);
        }

        function getForwardVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            return playerDirection;
        }

        function getSideVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            playerDirection.cross(camera.up);
            return playerDirection;
        }

        function controls(deltaTime) {
            const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);
            if (keyStates['KeyW']) playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
            if (keyStates['KeyS']) playerVelocity.add(getForwardVector().multiplyScalar(-speedDelta));
            if (keyStates['KeyA']) playerVelocity.add(getSideVector().multiplyScalar(-speedDelta));
            if (keyStates['KeyD']) playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
        }

        function teleportPlayerIfOob() {
            if (camera.position.y <= -25) {
                playerVelocity.set(0, 0, 0);
                playerCollider.start.set(0, 0.35, 0);
                playerCollider.end.set(0, 1.35, 0);
                camera.position.copy(playerCollider.end);
            }
        }

        // --- 애니메이션 루프 ---
        function animate() {
            const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;

            for (let i = 0; i < STEPS_PER_FRAME; i++) {
                // ★ 수정된 부분: 모델 로딩이 끝난 후에만 물리 엔진(중력) 작동
                if (isModelLoaded) {
                    controls(deltaTime);
                    updatePlayer(deltaTime);
                    teleportPlayerIfOob();
                }
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>

